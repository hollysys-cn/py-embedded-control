# 功能规格说明：PLCopen Python 运行时环境

**功能分支**: `001-plcopen-python-runtime`
**创建日期**: 2026-01-17
**状态**: 草案
**输入**: 用户描述："一个嵌入式程序，包含plcopen基础功能块：pid、一阶惯性等;程序支持python脚本，可以用python调用包含plcopen基础功能块；程序运行在linux中；支持远程调试python脚本，来完成一个简单的控制逻辑(比如pid温度控制)。"

## Clarifications

### Session 2026-01-17

- Q: 当 Python 脚本执行时间超过控制周期时间时，系统如何保证实时性？ → A: 记录日志警告但继续执行，允许偶尔超时
- Q: 远程调试会话中断（网络故障）时，控制逻辑是否继续运行？ → A: 控制逻辑继续运行，调试会话独立于控制执行
- Q: 功能块状态在 Python 脚本重启后是否需要保留？ → A: 不保留，脚本重启时功能块状态重新初始化
- Q: 功能块参数超出合理范围（如 PID 参数为负数或极大值）时，系统如何处理？ → A: 限制到有效范围并记录警告
- Q: 多个 Python 脚本同时运行时，功能块资源如何隔离和管理？ → A: 本版本不支持多脚本并发，单脚本运行

## 用户场景与测试 *(必填)*

### 用户故事 1 - 基础功能块调用 (优先级: P1)

作为控制工程师，我需要在 Python 脚本中调用 PLCopen 标准功能块（如 PID 控制器），以便快速实现控制逻辑而无需重新编写底层算法。

**优先级理由**：这是系统的核心价值，没有这个功能，系统无法提供任何有用的控制能力。这是最小可行产品（MVP）的基础。

**独立测试**：可以通过编写一个简单的 Python 脚本调用 PID 功能块，输入设定值和反馈值，验证输出是否符合 PID 算法预期。无需其他功能即可验证此功能完整性。

**验收场景**：

1. **Given** Python 脚本已导入 PLCopen 功能块库，**When** 创建 PID 控制器实例并调用其计算方法，**Then** 返回正确的控制输出值
2. **Given** PID 控制器已配置参数（Kp、Ki、Kd），**When** 输入设定值和反馈值，**Then** 控制器输出根据 PID 算法计算的结果
3. **Given** 一阶惯性功能块已创建，**When** 输入阶跃信号，**Then** 输出按一阶惯性环节响应特性变化
4. **Given** 功能块在运行中，**When** 修改功能块参数，**Then** 功能块使用新参数继续运行

---

### 用户故事 2 - 完整控制回路示例 (优先级: P2)

作为控制工程师，我需要运行一个完整的 PID 温度控制示例程序，以便验证系统能够处理实际的闭环控制场景。

**优先级理由**：这是对 P1 功能的实际应用验证，证明系统不仅能调用单个功能块，还能组合成完整的控制逻辑。这是向用户展示系统价值的关键场景。

**独立测试**：可以独立运行温度控制示例程序（即使是模拟的温度传感器和执行器），验证 PID 控制器能够使模拟温度收敛到设定值。无需远程调试功能即可测试。

**验收场景**：

1. **Given** 系统启动并加载温度控制 Python 脚本，**When** 设定目标温度为 25°C，**Then** 系统通过 PID 控制器调节输出，使模拟温度逐渐接近 25°C
2. **Given** 温度已稳定在设定值，**When** 改变设定值为 30°C，**Then** PID 控制器重新调节，使温度收敛到新设定值
3. **Given** 控制回路运行中，**When** 引入外部干扰（模拟热负载变化），**Then** PID 控制器能够抵抗干扰，维持温度稳定
4. **Given** 控制逻辑包含多个功能块（PID + 一阶惯性滤波），**When** 执行控制周期，**Then** 各功能块按顺序执行，输出正确的控制信号

---

### 用户故事 3 - 远程调试 Python 脚本 (优先级: P3)

作为控制工程师，我需要从开发机远程连接到 Linux 嵌入式设备，调试正在运行的 Python 控制脚本，以便快速定位和修复控制逻辑中的问题。

**优先级理由**：远程调试极大提高开发效率，但不是系统运行的必要条件。用户可以先通过日志或本地调试完成开发，远程调试是锦上添花的功能。

**独立测试**：可以在开发机上启动调试客户端（如 VS Code），连接到运行在 Linux 设备上的 Python 脚本，设置断点、单步执行、查看变量。无需依赖 P1 和 P2 的完整控制逻辑，使用简单的测试脚本即可验证调试功能。

**验收场景**：

1. **Given** Python 脚本在 Linux 设备上运行，并启用了调试服务器，**When** 开发机上的调试器通过网络连接到设备，**Then** 调试器成功连接并显示脚本当前状态
2. **Given** 调试器已连接，**When** 在 Python 脚本中设置断点，**Then** 脚本运行到断点处暂停
3. **Given** 脚本在断点处暂停，**When** 用户单步执行或查看变量值，**Then** 调试器显示正确的执行流程和变量内容
4. **Given** 调试会话进行中，**When** 用户修改变量值并继续执行，**Then** 脚本使用修改后的值继续运行
5. **Given** 调试会话结束，**When** 用户断开调试器，**Then** 脚本继续正常运行（如果配置为非中断模式）

---

### 边界情况

### 边界情况

- **功能块参数超出合理范围**：系统自动限制（clamp）到有效范围并记录警告日志（例如 PID 的 Kp/Ki/Kd 限制为非负数，极大值限制到合理上限）。
- **Python 脚本执行时间超过控制周期时间**：系统记录日志警告但继续执行当前周期，允许偶尔超时（避免控制不连续）。
- **远程调试会话中断（网络故障）**：控制逻辑继续运行，调试会话独立于控制执行（确保生产连续性）。
- **功能块状态在 Python 脚本重启后**：不保留状态，脚本重启时功能块重新初始化为默认参数（简化实现，从干净状态开始）。

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系统必须提供 PLCopen 标准功能块的 C 语言实现，包括但不限于 PID 控制器、一阶惯性环节
- **FR-002**: 系统必须提供 Python 绑定（binding），使 Python 脚本能够调用 C 语言实现的功能块
- **FR-003**: Python 脚本必须能够创建功能块实例、配置参数、调用计算方法；参数超出范围时自动限制到有效范围并记录警告
- **FR-004**: 系统必须在 Linux 操作系统上运行（支持主流发行版如 Ubuntu、Debian）
- **FR-005**: 系统必须支持周期性执行 Python 控制脚本（可配置的执行周期）
- **FR-006**: 系统必须提供示例程序，演示如何使用 Python 调用功能块完成 PID 温度控制
- **FR-007**: 系统必须支持远程调试协议（如 debugpy 或 pdb），允许开发机通过网络连接进行调试；调试会话中断时控制逻辑继续运行
- **FR-008**: 系统必须记录运行日志，包括功能块调用、参数变化、异常错误、控制周期超时警告
- **FR-009**: 系统必须处理 Python 脚本异常，避免单个脚本错误导致整个系统崩溃；当脚本执行超时时记录警告但允许完成
- **FR-010**: 功能块参数必须可在运行时动态修改（通过 Python API）
- **FR-011**: 系统必须提供 API 文档，说明每个功能块的参数、方法和使用示例（简体中文）
- **FR-012**: 系统启动时必须能够自动加载指定的 Python 控制脚本（通过配置文件指定）；本版本仅支持单个脚本运行

### 关键实体

- **功能块（Function Block）**：PLCopen 标准功能块的抽象，包含状态、参数和计算逻辑。每个功能块类型（如 PID、一阶惯性）有对应的 C 语言实现和 Python 接口。
- **Python 脚本（Python Script）**：用户编写的控制逻辑，调用功能块实现具体的控制任务。脚本在运行时环境中周期性执行。
- **运行时环境（Runtime Environment）**：负责加载 Python 解释器、管理功能块实例、调度脚本执行、处理调试连接的核心程序。运行在 Linux 上。
- **调试会话（Debug Session）**：开发机与嵌入式设备之间的调试连接，允许远程控制脚本执行、查看变量、设置断点。

## 成功标准 *(必填)*

### 可度量的成果

- **SC-001**: 用户可以在 10 分钟内通过阅读文档和示例代码，成功运行第一个 PID 控制示例（从零开始到看到控制效果）
- **SC-002**: Python 脚本调用功能块的执行周期稳定性达到 95% 以上（即 95% 的周期在设定时间 ±5% 范围内完成）
- **SC-003**: 系统支持至少 10 个功能块实例同时运行，且 CPU 占用率低于 50%（在典型嵌入式处理器如 ARM Cortex-A7 上）
- **SC-004**: 远程调试连接建立时间少于 5 秒，断点响应时间少于 1 秒
- **SC-005**: PID 功能块输出精度符合 PLCopen 标准定义，与标准参考实现的误差小于 0.1%
- **SC-006**: 系统在长时间运行（24 小时）后，内存占用增长小于 10%（无明显内存泄漏）
- **SC-007**: 90% 的用户能够在首次尝试时成功配置并启动远程调试（基于用户测试反馈）
- **SC-008**: 系统提供的示例代码覆盖所有基础功能块（PID、一阶惯性等），每个示例代码行数少于 50 行（易于理解）

## 假设

- 假设目标 Linux 设备已安装 Python 3.8 或更高版本
- 假设用户具备基本的 Python 编程能力和控制系统知识（理解 PID 原理）
- 假设嵌入式设备具有网络连接能力（用于远程调试）
- 假设 PLCopen 功能块实现遵循 IEC 61131-3 标准
- 假设控制周期时间在 10ms 到 1000ms 范围内（典型的工业控制应用）

## 范围边界

### 包含在范围内
- PLCopen 基础功能块：PID、一阶惯性、斜坡、限幅等常用功能块
- Python 到 C 的双向调用机制（Python 调用 C 功能块）
- 基于 debugpy 或类似协议的远程调试支持
- 温度控制示例程序（作为参考实现）
- 基础的日志和异常处理机制

### 不包含在范围内
- 图形化编程界面（本期仅支持文本编程）
- 实时操作系统（RTOS）支持（仅支持标准 Linux）
- 硬件 I/O 驱动程序（假设用户自行实现或使用模拟 I/O）
- 分布式控制系统（多设备协同）
- 多个 Python 脚本并发运行（本版本仅支持单脚本）
- 安全认证机制（远程调试暂不考虑加密和身份验证）
- 历史数据存储和可视化（仅实时控制和调试）
- 功能块状态持久化（脚本重启后状态不保留）

## 依赖关系

- **外部依赖**：
  - Python 3.8+ 及标准库
  - C 编译器（GCC 或 Clang，支持 C11 标准）
  - Linux 内核 4.x 或更高版本
  - debugpy 库（用于远程调试，通过 pip 安装）

- **内部依赖**：
  - 无（这是项目的第一个功能）
